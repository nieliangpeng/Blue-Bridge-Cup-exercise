1.
问题描述
　　给定一个长度为n的数列，将这个数列按从小到大的顺序排列。1<=n<=200
输入格式
　　第一行为一个整数n。
　　第二行包含n个整数，为待排序的数，每个整数的绝对值小于10000。
输出格式
　　输出一行，按从小到大的顺序输出排序后的数列。
样例输入
5
8 3 6 4 9
样例输出
3 4 6 8 9
 

#include<iostream>
using namespace std;


int main(void)
{
 int n,i,j,mept;
 int *f;
cin>>n;
f=new int[n];
for(i=0;i<n;i++) cin>>*(f+i);

for(i=n-1;i>=1;i--){
	for(j=0;j<=i-1;j++){
		if(*(f+j)>*(f+j+1)){
			mept=*(f+j);
			*(f+j)=*(f+j+1);
			*(f+j+1)=mept;
		}
	} 
}
for(i=0;i<n;i++) cout<<*(f+i)<<" ";
delete []f;
return 0;
}



2.
十六进制转八进制

#include<iostream>
using namespace std;
int main(void){
	int a,n,i;
	cin>>n;
	int *array;
	array=new int[n];
	for(i=0;i<n;i++){
		cin>>hex>>*(array+i);
	}
    
	for(i=0;i<n;i++){
		cout<<oct<<*(array+i)<<endl;
	}
	delete []array;
	return 0;
}

#include<iostream>
using namespace std;
int main(void){
	int numble;
    cin>>hex>>numble;
    cout<<dec<<numble;
	
	
	return 0;
}

问题描述
　　123321是一个非常特殊的数，它从左边读和从右边读是一样的。
　　输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。
输入格式
　　输入一行，包含一个正整数n。
输出格式
　　按从小到大的顺序输出满足条件的整数，每个整数占一行。
样例输入
52
样例输出
899998
989989
998899
数据规模和约定
　　1<=n<=54。


#include<stdio.h>
#include <time.h> 
#include<iostream>
using namespace std;
int main(void){
    int numble;
    cin>>dec>>numble;
    printf("%X",numble);//直接cout<<hex<<numble;输出的是小写的字母，不行，用这个必须加头文件；
	
	
	return 0;
}

    %x输出十六进制
    printf("%x\n", j);  //输出结果为:    2f
    printf("%X\n", j);  //输出结果为:    2F
    printf("%#x\n", j); //输出结果为:    0x2f
    printf("%#X\n", j); //输出结果为:    0X2F    %#X推荐使用



#include<stdio.h>
#include<iostream>
using namespace std;
int main(void){
	int num,i,a,b,c,d,e,f;
	cin>>num;
    for(i=10000;i<=99999;i++){
    	a=i/10000;
    	b=(i-10000*a)/1000;
    	c=(i-10000*a-1000*b)/100;
    	d=(i-10000*a-1000*b-100*c)/10;
    	e=(i-10000*a-1000*b-100*c-10*d)/1;
    	if(a==e&&b==d){
    		if(a+b+c+d+e==num){
    			cout<<i<<endl;
    		}
    	}
    }
	for(i=100000;i<=999999;i++){
		a=i/100000;
    	b=(i-100000*a)/10000;
    	c=(i-100000*a-10000*b)/1000;
    	d=(i-100000*a-10000*b-1000*c)/100;
    	e=(i-100000*a-10000*b-1000*c-100*d)/10;
    	f=(i-100000*a-10000*b-1000*c-100*d-10*e)/1;
    	if(a==f&&b==e&&c==d){
    		if(a+b+c+d+e+f==num){
    			cout<<i<<endl;
    		}
    	}
	}
	//cout<<"\n     "<<clock()<< " ms";
	return 0;
}




#include<stdio.h>
#include <time.h> 
#include<iostream>
using namespace std;
int main(void){
	int num,i,a,b,c,d;
	
    for(i=1000;i<=9999;i++){
    	a=i/1000;
    	b=(i-1000*a)/100;
    	c=(i-1000*a-100*b)/10;
    	d=(i-1000*a-100*b-10*c)/1;
    	
    	if(a==d&&b==c){
    	   cout<<i<<endl;
    		
    	}
    }

	//cout<<"\n     "<<clock()<< " ms";
	return 0;
}

杨辉三角形又称Pascal三角形，它的第i+1行是(a+b)i的展开式的系数。

　　
它的一个重要性质是：三角形中的每个数字等于它两肩上的数字相加。

　　
下面给出了杨辉三角形的前4行：

　　
   1

　　
  1 1

　　
 1 2 1

　　
1 3 3 1

　　
给出n，输出它的前n行。

输入格式
输入包含一个数n。

输出格式
输出杨辉三角形的前n行。每一行从这一行的第一个数开始依次输出，中间使用一个空格分隔。请不要在前面输出多余的空格。
样例输入
4
样例输出
1
1 1
1 2 1
1 3 3 1
数据规模与约定
1 <= n <= 34。

#include<iostream>
#include<string.h>
#include<time.h> 
using namespace std;
int main()
{
 int count=0,n,a[35][35],i,j;
 for(i=0;i<35;i++){
 	for(j=0;j<35;j++){
 		a[i][j]=0;
 	}
 } 
 cin>>n;
 for(int i=0;i<n;i++)
 {
 for(int j=0;j<=i;j++)
 { 
 if(j<1) a[i][j]=1;//如果是i+1行第一个数，就置1
    else
 a[i][j]=a[i-1][j-1]+a[i-1][j];//第i+1行第j+1个数等于上一行第j个数加第j+1个数
}
 }
 for(i=0;i<n;i++)
 {
 for(j=0;j<=i;j++)
    cout<<a[i][j]<<" ";//循环输出
    cout<<endl;
 }
 cout<<"运行时间"<<clock()<<endl;
 return 0;
}
